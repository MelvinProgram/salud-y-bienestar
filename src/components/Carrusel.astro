---
const { images = [], height = "50%"} = Astro.props;
---

<div class="carousel-container shadow-lg shadow-black/50 rounded-3xl mt-8"
     style={`height: ${height}`}
     data-carousel>
  <div class="carousel-track" data-carousel-track>
    {images.map((img: string) => (
      <img src={img} alt="slide" class="carousel-slide object-cover h-full" />
    ))}
  </div>

  <!-- Flechas: uso clases Tailwind aquí para evitar @apply dentro de <style> -->
  <button type="button"
          aria-label="Anterior"
          class="absolute top-1/2 -translate-y-1/2 bg-black/40 text-white p-2 rounded-full cursor-pointer hover:bg-black/60 transition left-3 py-4"
          data-prev>
    ❮
  </button>

  <button type="button"
          aria-label="Siguiente"
          class="absolute top-1/2 -translate-y-1/2 bg-black/40 text-white p-2 rounded-full cursor-pointer hover:bg-black/60 transition right-3 py-4"
          data-next>
    ❯
  </button>

  <!-- Puntos -->
  <div class="flex justify-center gap-2 absolute bottom-3 left-1/2 -translate-x-1/2" data-dots></div>
</div>

<script type="module">
  (function () {
    // seleccionar todos los carruseles en la página (permite múltiples)
    const carousels = document.querySelectorAll('[data-carousel]');

    carousels.forEach((root) => {
      const track = root.querySelector('[data-carousel-track]');
      const slides = track ? Array.from(track.children) : [];
      const prevBtn = root.querySelector('[data-prev]');
      const nextBtn = root.querySelector('[data-next]');
      const dotsContainer = root.querySelector('[data-dots]');

      if (!track || slides.length === 0) {
        // nada que mostrar
        if (dotsContainer) dotsContainer.style.display = 'none';
        if (prevBtn) prevBtn.style.display = 'none';
        if (nextBtn) nextBtn.style.display = 'none';
        return;
      }

      let index = 0;
      let interval = null;
      const INTERVAL_MS = 4000;

      // crear puntos
      // slides.forEach((_, i) => {
      //   const dot = document.createElement('button');
      //   dot.type = 'button';
      //   dot.className = 'w-3 h-3 rounded-full bg-white/40 cursor-pointer';
      //   dot.setAttribute('aria-label', `Ir a la diapositiva ${i + 1}`);
      //   dot.dataset.index = String(i);
      //   dotsContainer.appendChild(dot);
      // });

      const dots = Array.from(dotsContainer.children); 

      function updateDots() {
        dots.forEach(d => d.classList.remove('bg-white'));
        if (dots[index]) dots[index].classList.add('bg-white');
      }

      function updateCarousel() {
        // transform con porcentaje
        track.style.transform = `translateX(-${index * 100}%)`;
        updateDots();
      }

      function nextSlide() {
        index = (index + 1) % slides.length;
        updateCarousel();
      }

      function prevSlide() {
        index = (index - 1 + slides.length) % slides.length;
        updateCarousel();
      }

      function startAuto() {
        stopAuto();
        interval = setInterval(nextSlide, INTERVAL_MS);
      }

      function stopAuto() {
        if (interval) {
          clearInterval(interval);
          interval = null;
        }
      }

      // listeners flechas
      if (nextBtn) {
        nextBtn.addEventListener('click', () => {
          nextSlide();
          startAuto();
        });
      }

      if (prevBtn) {
        prevBtn.addEventListener('click', () => {
          prevSlide();
          startAuto();
        });
      }

      // listeners puntos
      dots.forEach(dot => {
        dot.addEventListener('click', (e) => {
          const target = e.currentTarget;
          const i = parseInt(target.dataset.index, 10);
          if (!Number.isNaN(i)) {
            index = i;
            updateCarousel();
            startAuto();
          }
        });
      });

      // pausa al hover
      root.addEventListener('mouseenter', stopAuto);
      root.addEventListener('mouseleave', startAuto);

      // soporte touch: touchstart, touchmove, touchend
      let startX = 0;
      let deltaX = 0;

      root.addEventListener('touchstart', (e) => {
        stopAuto();
        if (e.touches && e.touches.length > 0) {
          startX = e.touches[0].clientX;
          deltaX = 0;
        }
      }, {passive: true});

      root.addEventListener('touchmove', (e) => {
        if (e.touches && e.touches.length > 0) {
          deltaX = e.touches[0].clientX - startX;
        }
      }, {passive: true});

      root.addEventListener('touchend', () => {
        const threshold = 50; // px
        if (deltaX < -threshold) {
          nextSlide();
        } else if (deltaX > threshold) {
          prevSlide();
        }
        startAuto();
        startX = 0;
        deltaX = 0;
      });

      // inicializar
      updateCarousel();
      startAuto();

      // cleanup si el nodo se elimina (defensivo)
      // (esto no siempre se necesita, pero ayuda en SPA o re-mounts)
      const observer = new MutationObserver(() => {
        if (!document.body.contains(root)) {
          stopAuto();
          observer.disconnect();
        }
      });
      observer.observe(document.body, { childList: true, subtree: true });
    });
  })();</script>